1) In C++, it is a compiler error to call a function before it is declared. But in C, it may compile

2) In C++, it is compiler error to make a normal pointer to point a const variable, but it is allowed in C. 

3) In C, a void pointer can directly be assigned to some other pointer like int *, char *. But in C++, a void pointer must be explicitly typcasted.

4) Following program compiles & runs fine in C, but fails in compilation in C++. const variable in C++ must be initialized but in c it isn’t necessary. Thanks to Pravasi Meet for suggesting this point.
#include <stdio.h>
int main()
{
    const int a;   // LINE 4
    return 0;
}

5) This is the worst answer among all, but still a valid answer. We can use one of the C++ specific keywords as variable names. The program won’t compile in C++, but would compiler in C.
#include <stdio.h>
int main(void)
{
    int new = 5;  // new is a keyword in C++, but not in C
    printf("%d", new);
}

6) C++ does more strict type checking than C. For example the following program compiles in C, but not in C++. In C++, we get compiler error “invalid conversion from ‘int’ to ‘char*'”. 
#include <stdio.h>
int main()
{
    char *c = 333;
    printf("c = %u", c);
    return 0;
} 

7) Call Puzzle
Consider the following program. Predict the output of it when compiled with C and C++ compilers.
void func()
{
    /* definition */
}
 
int main()
{
    func();
    func(2);
}
In C++, func() is equivalent to func(void)
In C, func() is equivalent to func(…)
